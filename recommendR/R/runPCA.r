#' runPCA runs principal component analysis using the prcomp function

#' \code{runPCA} takes the first N PCs (latent variables) and 
#' maps users onto the new N dimensional space

#'@param filePath genre table generated by genre2matrix in the tools folder
#'@param the number of PCs to consider

#'@export
runPCA <- function(table, Npc){
    df    <- read.table(table, sep="\t")
    PCAdf <- df %>% 
            select(-user, -gender, -country) %>% 
            prcomp(center=T, scale.=T)
    message("Running Principal Component Analysis")
    numPC       <- choosePC(PCAdf)
    PCAdf$x[,1:numPC]
}

#' closest finds videos to recommend based on the PCA matrix

#' Closest finds the closest users (Ux) for each user (U0)
#' selects videos which they (Uxs) have watched and recommends to U0 
#' videos watched by Uxs but not U0

#'@param latentVars could be as many N as possible
#'@param distance the type of distance formula to use, defaults to euclidian distance
#'@param integer representing the top N closest users; defaults to 5

#' @export
closest <- function(latentVars, distance="euclidian", top = 5){
    aDist <- latentVars %>% dist %>% as.matrix
    outCSV = 1:nrow(aDist) %>% 
        mclapply(function(rowID){
            closestUsers = dff[head(order(aDist[-1,rowID]),top)+1,1] #we take the ten most similar 100 users
            closestVids = unique(filter(hiScoreVideo, user_id %in% closestUsers)$video_id)

            #videos which user has seen
            hisVids = filter(hiScoreVideo, user_id == dff[rowID,1])$video_id
            candidates = closestVids[which(!closestVids %in% hisVids)]
    })

#' choosePC determines the N of PCs to consider to account for ~50% fo the variability

#' the function finds cumulative variance of Principal Components and find the number of PCs 
#' required to account for 50% of the variance

#' @param pcaObj the PCA object
#' @param variance the threshold amt of variance that is required

choosePC <- function(pcaObj, variance = .5){
    cumVariance <- hiFreqPCA %>%
        summary              %$%
        importance[2,]       %>%
        cumsum
    #pdf("cumVariance.pdf")
    #qplot(x=as.factor(1:length(cumVariance)), y=cumVariance) + ylim(0,1)
    #dev.off()
    max(which(cumVariance < threshold))
}


